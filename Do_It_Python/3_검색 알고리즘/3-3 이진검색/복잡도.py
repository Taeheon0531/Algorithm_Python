"""
복잡도 complexity : 알고리즘의 성능을 객관적으로 평가하는 기준

종류
1. 시간 복잡도 (time complexity)    - 실행하는데 필요한 시간을 평가

2. 공간 복잡도 (space complexity)   - 메모리(기억공간)와 파일 공간이 얼마나 필요한지를 평가

[예시] 선형 검색의 시간 복잡도
def seq_search(a: Sequence, key: Any) -> int                
    i = 0                                                   (1단계)

    while i < n:                                            (2단계)
        if a[i] == key:                                     (3단계)
            return i    # 검색에 성공하여 인덱스를 반환             (4단계)
        i += 1                                               (5단계)
    
    return -2           # 검색에 실패하여 -1을 반환               (6단계)


1 - 6 단계의 실행 횟수

        횟수    복잡도
1단계     1     O(1)
2단계    n/2    O(n)
3단계    n/2    O(n)
4단계     1     O(1)
5단계    n/2    O(n)
6단계     1     O(1)

1번만 실행되면 복잡도가 O(1)    (O: order.... O(n)은 order n이라고 읽음)
n에 비례하는 횟수만큼 실행되면 복잡도가 O(n)

n이 점점 커지면 O(n)에 필요한 계산 시간은 n에 비례하여 점점 길어짐
O(1)에 필요한 계산 시간은 변하지 않음

따라서 O(f(n)) 과 O(g(n))의 동작을 연속으로 하는 경우 복잡도
O(f(n)) + O(g(n)) = O(max(f(n),g(n)))

** 따라서 전체 복잡도는 차원이 가장 높은 복잡도를 선택하는 것
=> O(1) + O(n) + O(n) + O(1) + O(n) + O(1) = O(max(1, n, n, 1, n, 1)) = O(n)


복잡도의 대소 관계
1 < log n < n < n log n < n^2 < n^3 < n^k < 2^n

"""