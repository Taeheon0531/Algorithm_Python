"""
파이썬에서 배열의 종류 : 리스트, 튜플
"""

"""
* 리스트
= 원소를 변경할 수 있는 mutable list형 객체
"""
list01 = [] # 빈 리스트
list02 = [1, 2, 3]  # [1, 2, 3]
list03 = ['A', 'B', 'C', ]    # ['A', 'B', 'C'] 맨 마지막 원소에 쉼표를 써도 됨

list04 = list() # [] 빈 리스트
list05 = list('ABC')    # ['A', 'B', 'C'] 문자열의 각 문자로부터 원소를 생성
list06 = list([1, 2, 3])    # [1, 2, 3] 리스트로부터 원소를 생성
list07 = list((1, 2, 3))    # [1, 2, 3] 튜플로부터 원소를 생성
list08 = list({1, 2, 3})    # [1, 2, 3] 집합으로부터 원소를 생성

list09 = list(range(7)) # [0, 1, 2, 3, 4, 5, 6]
list10 = list(range(3, 8))  # [3, 4, 5, 6, 7]
list11 = list(range(3, 13 ,2))  # [3, 5, 7, 9, 11]

list12 = [None] * 5 # [None, None, None, None, None]


"""
* 튜플
= 원소를 변경할 수 없는 immutable 자료형
튜플은 리스트와 다르게 결합 연산자 ()를 생략할 수 있음
"""
tuple01 = ()    # () 빈 튜플
tuple02 = 1,    # (1,)  쉼표를 반드시 입력해야함 (없으면 튜플로 인식 x)
tuple03 = (1,)  # (1,)  쉼표를 반드시 입력해야함 (없으면 튜플로 인식 x)
tuple04 = 1, 2, 3   # (1, 2, 3)
tuple05 = 1, 2, 3,  # (1, 2, 3)
tuple06 = (1, 2, 3) # (1, 2, 3)
tuple07 = (1, 2, 3, )   # (1, 2, 3)
tuple08 = 'A', 'B', 'C' # ('A', 'B', 'C')

v01 = 1     # 튜플이 아닌 하나의 값을 가진 int형 변수
v02 = (1)   # 튜플이 아닌 하나의 값을 가진 int형 변수

tuple09 = tuple()   # () 빈 튜플
tuple10 = tuple('ABC')  # ('A', 'B', 'C') 문자열의 각 문자로부터 원소를 생성
tuple11 = tuple([1, 2, 3])  # (1, 2, 3) 리스트로부터 원소를 생성
tuple12 = tuple({1, 2, 3})  # (1, 2, 3) 리스트로부터 원소를 생성

tuple13 = tuple(range(7))   # (0, 1, 2, 3, 4, 5, 6)
tuple14 = tuple(range(3, 8))    # (3, 4, 5, 6, 7)
tuple15 = tuple(range(3, 13, 2))    # (3, 5, 7, 9, 11)


"""
리스트와 튜플 풀어내기 (Unpack)
좌변에는 여러 개의 변수
우변에는 리스트나 튜플
=> 우변의 원소를 좌변의 변수에 한번에 대입 가능
"""
x = [1, 2, 3]   # 리스트 x 선언
a, b, c = x     # x를 언팩하여 변수 a, b, c에 대입


"""
인덱스식 사용하기
* 앞에서부터는 0, 1, 2
* 뒤에서부터는 -1, -2, -3
"""
x = [11, 22, 33, 44, 55, 66, 77]
print(x[2])     # 리스트 x의 앞에서 3번째 원소 출력
print(x[-3])    # 리스트 x의 뒤에서 3번째 원소 출력

x[-4] = 3.14
print(x)        # [11, 22, 33, 3.14, 55, 66, 77]
x[7] = 3.14     # 에러 (존재하지 않는 원소에 접근하거나 대입해도 원소가 새롭게 추가되지 않음)


"""
슬라이스식으로 원소에 접근하기
* s[i:j]    s[i]부터  s[j-1]까지 나열
* s[i:j:k]  s[i]부터 s[j-1]까지 k씩 건너뛰며 나열
"""
s = [11, 22, 33, 44, 55, 66, 77]
print(s[0:6])   # 리스트 s의 0번째 원소부터 5번째 원소를 출력
print(s[0:7])   # 리스트 s의 0번째 원소부터 6번째 원소를 출력
print(s[0:7:2]) # 리스트 s의 0번째 원소부터 6번째 원소 중 2씩 건너뛰며 원소를 출력
print(s[-4:-2]) # 리스트 s의 뒤에서 4번째 원소부터 뒤에서 2번째 원소를 출력
print(s[3:1])   # 결과값: []  - 리스트 s의 j값(1)이 i값(3)보다 작지만 오류가 나지 않음
"""
i, j, k 를 지정하는 규칙
1. i, j 가 len(s)보다 크면 len(s)가 지정된 것으로 간주한다. 인덱스와 달리 범위에서 벗어나는 값을 지정해도 오류가 되지 않음
2. i 가 없거나 None이면 0 이 지정된 것으로 간주
3. j 가 없거나 None이면 len(s) 가 지정된 것으로 간주

패턴
1. s[:] 리스트 s의 원소를 모두 출력
2. s[:n]    리스트 s의 원소 중 맨 앞에서부터 n개까지 출력
3. s[i:]    리스트 s의 원소 중 s[i]부터 맨 끝까지 출력
4. s[-n:]   리스트 s의 원소 중 맨 끝에서부터 n개까지 출력
5. s[::k]   리스트 s의 원소 중 맨 앞에서부터 k개씩 건너뛰며 출력
6. s[::-1]  리스트 s의 원소 중 맨 끝에서부터 전부 출력
"""


"""
뮤터블과 이뮤터블의 대입

뮤터블 자료형: 리스트, 딕셔너리, 집합 등
이뮤터블 자료형: 수, 문자열, 튜플 등
"""
x = 6
y = 2
x, y = y + 2, x + 3

# x = 4
# y = 9     -> 동시에 처리


"""
+ 와 = 은 다르다
x + 17 은 식
x = 17 은 문

즉 파이썬에서 = 은 결합연산자가 아님

c,c++,java 에서는 a = (b = 1)  가능
python 에서는 a = (b = 1)      syntaxError
"""


"""
리스트와 튜플 보충
"""
# len 함수로 배열의 원소 수 구하기
ex = [15, 64, 7, 3.14, [32, 55], 'ABC']
print(len(ex))          # 6 (리스트 또는 튜플을 1개로 취급)

# 빈 배열 판단하기
if x:   # x가 비어있지 않으면 (True) 실행
else:   # x가 비어있으면 (False) 실행

# 비교연산자로 배열의 대소 또는 등가 관계 판단하기
# [1, 2, 3] == [1, 2, 3]
# [1, 2, 3] < [1, 2, 4]
# [1, 2, 3, 4] <= [1, 2, 3, 4]
# [1, 2, 3] < [1, 2, 3, 5]
# [1, 2, 3] < [1, 2, 3, 5] < [1, 2, 3, 5, 6]     (and 결합)
# 맨 앞 원소부터 차례로 비교하면서 원소의 값이 같으면 다음 원소를 비교
# 만약 어느 원소의 값이 크면 그 배열이 큰 것으로 판단
# 배열의 원소 수가 다른 경우에는 원소 수가 많은 배열을 더 크다고 판단

# 등가성과 동일성
# 좌변과 우변이 같은지 비교 : =
# 값은 물론 객체의 식별 번호까지 같은지 비교: is

# 내포 표기
numbers = [1, 2, 3, 4, 5]
twise = [num * 2 for num in numbers if num % 2 == 1]    # 리스트 numbers의 홀수 원솟값을 *2한 리스트 생성
print(twise)    # [2, 6, 10]